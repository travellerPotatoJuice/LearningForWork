# 解题模板

https://www.bilibili.com/video/BV1fA4y1o715/?spm_id_from=333.337.search-card.all.click&vd_source=5bafb5422f498623f75773061f60b9e7

看一下以上视频。

解二分查找的关键在于对循环不变量的定义，也就是对区间的定义。

# 常用函数





# 题目

## 4.寻找两个正序数组的中位数

**法一：**暴力

+ 使用System.arraycopy()合并两个数组
+ 使用Arrays.sort()对数组进行排序
+ 根据元素的个数计算中位数



**法二：**双指针

+ 因为已知数组长度，所以可以知道中位数的下标
+ 维护两个指针，每次让较小的指针向后移动一位



## 33.搜索旋转排序数组

**法一：**二分查找

+ 第一次二分查找先查找出旋转的位置。如果nums[mid]>nums[left]，说明left~mid是顺序，则left=mid; 如果nums[mid]<nums[left]，说明mid~right是顺序，则right=mid；
+ 分别对两边的顺序数组进行二分查找。



## 34. 在排序数组中查找元素的第一个和最后一个位置

**法一：**二分查找 【边界条件】

+ 查找第一个>=target的元素
+ 查找第一个>target的元素





## 35.搜索插入位置

**法一：**二分查找



## 74.搜索二维矩阵

**法一：**逐层二分查找



## 153.寻找旋转排序数组中的最小值

**法一：**二分查找







## 162.寻找峰值

**法一：**哈希表

+ 遍历元素，存入哈希表，key为元素值，value为下标
+ 寻找最大的元素，返回其下标



**法二：**

+ 在[0,n)之间随机初始化一个i
+ 如果nums[i-1]<nums[i]>nums[i+1]，则i处就有一个峰值
+ 如果nums[i-1]<nums[i]<nums[i+1]，则i=i+1;
+ 如果nums[i-1]>nums[i]>nums[i+1]，则i=i-1;
+ 如果nums[i-1]>nums[i]<nums[i+1]，则朝任意方向走



## 222.完全二叉树的节点个数

**法一：**递归

+ 节点数等于左子树节点数+右子树节点数+1；
+ 递归结束条件：如果root==null就返回0;



**法二：**二分查找 【想不到】

+ 因为题目里特别说到了是完全二叉树，所以可以利用一下这个条件

+ 根据完全二叉树的特性可知，完全二叉树的**最左边的节点一定位于最底层**，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数 h

+ 得到最大层数之后就可以将节点的个数确定在[2^h,2^(h+1)-1]的区间内了

+ 在这个区间内进行二分，假设要查找的是第k个节点，这个节点位于h层，则k的二进制表示包含h+1位

  