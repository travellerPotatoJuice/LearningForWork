# 常见函数与思想

## 异或

+ 任何数和其本身异或，结果为0
+ 任何数和0异或，结果为其本身



## a与b的和

+ a+b = a^b + (a&b)<<1
+ a^b (a与b的和中不带进位的部分)
+ (a&b)<<1 (a与b的和中带进位的部分)



## MASK

统计n中的1的个数：Integer.bitCount(n);

mask：用十六进制数表示自己想要取的位数

例如：如果想要知道一个整数n偶数位的数字是否是1，就可以让这个整数与上0x5555(0101 0101 0101 0101)，然后调用Integer.bitCount



# 题目

## 190.颠倒二进制位





## 231. 2的幂

**法一：**位运算

+ 满足2的幂的数字都可以表示为100...
+ 这些数-1，就是011...
+ n&(n-1)==0的数就是2的幂



## 342. 4的幂

**法一：**位运算

+ 和231联系起来看
+ 一个满足2的幂的数只有两种情况，满足2的奇数次幂，满足2的偶数次幂
+ 满足2的奇数次幂的数mod3 ==2，满足2的偶数次幂的数mod3==1
+ 只需要判断n&(n-1)是否等于1，n mod 3是否为1即可



## 1684. 统计一致字符串的数目

**法一：**hashSet

+ 将allowed中的字母加入hashSet
+ 维护一致字符串的数量count
+ 遍历words中的字符串，如果包含不存在于hashSet中的字符，则将flag置为false；
+ 否则flag=true；
+ 如果遍历完某个字符串中的字符flag仍然为true，将count++



**法二：**与

+ 用int mask来记录字符情况
+ 因为有26个字符，所以只能用32位的int或者位数更长的long
+ mask |= 1<<(c-'a'); mask1为字符串数组中字符串的mask
+ 如果 （mask|mask1）==mask，结果就加1





## 1720. 解码异或后的数组

**法一：**位运算

+ encoded[i] = arr[i] XOR arr[i+1];
+ arr[i+1] = encoded[i] XOR arr[i] ;





## 2592.奇偶位数

**法一：**与运算+移位

+ n与1进行与运算，如果为1就证明这位是1
+ n右移1位



**法二：**掩码【想不到】

+ n和掩码mask相与
+ 统计Integer.bitCount(n&mask)



## 2859. 计算K置位下标对应元素的和

**法一：**

+ n&（n-1）每次都能消掉n的二进制表示最右边的1