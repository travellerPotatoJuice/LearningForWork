# 常用函数

+ toLowerCase()





# 题目

## 11.盛最多水的容器

**法一：**双指针【想不到】

+ 两个指针分别指向数组的开始和结尾
+ 计算容积，容积=(end-start)*min(height[start],height[end])
+ 维护一个变量作为全局最大值
+ 如果height[start]<height[end]，则start++；
+ 如果height[start]>height[end]，则end--；



## 15.三数之和

**法一：**排序后双指针 

+ 先对数组进行排序
+ 固定第一个元素，将second指向第一个元素后一个元素，third指向数组末尾，如果两个元素相加=target-nums[first]，则将first++。
+ 将结果添加到hashset中确保不会重复
+ 一直遍历到结束



## 125.验证回文串

**法一：**【想不到】

+ 遍历字符串，将字母和数字保留在一个新字符数组a1中
+ 使用**StringBuffer**的reverse()函数翻转a1，获得a2
+ 比较a1和a2是否相同

**法二：**

+ 原地使用双指针，将指针移到碰到的第一个字母或数字
+ 判断两个指针指向的字符是否相同



## 167.两数之和 II - 输入有序数组

**法一：**哈希表。

+ 创建一个HashMap<Integer,Integer>用于存储数组元素和索引
+ 遍历数组，寻找哈希表中是否存在target-nums[i]的key，若存在则输出索引
+ 时间复杂度O(n)，空间复杂度O(n)

**法二：**二分查找【想不到】

+ 先固定一个值
+ 在该值右侧的数组之中用二分查找寻找target-nums[i]
+ 时间复杂度*n*log*n*，空间复杂度O(1)

**法三：**双指针（因为题目强调了数组有序，并且一定存在唯一解）【想不到】

+ 指针分别指向数组第一个元素和最后一个元素
+ 如果指针所指元素之和=target，则找到了唯一解
+ 如果指针所指元素之和<target，左侧指针右移一位
+ 如果指针所指元素之和>target，右侧指针左移一位
+ 时间复杂度O(n)，空间复杂度O(1)



## 344. 反转字符串

**法一：**双指针

+ 指针分别指向开头和结尾
+ 交换元素，直到指针重合



## 392.判断子序列

**法一：**双指针。

+ 初始化指针i，j指向字符串s，t的初始位置
+ 匹配成功则同时后移，匹配失败则j后移
+ 如果i最后移动到s的末尾，说明匹配成功

**法二：**动态规划【想不到】

