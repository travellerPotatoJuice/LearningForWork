# JVM概述

**JVM组成**

+ 类加载器
+ 运行时数据区域（JVM管理的内存）
+ 执行引擎
+ 本地接口

![](image/20190505124743289.png)

## 类加载器

**类的生命周期**

+ 加载
+ 连接
  + 验证
  + 准备
  + 解析
+ 初始化
+ 使用
+ 卸载



## 运行时数据区域

+ 程序计数器（线程私有）
+ 虚拟机栈（线程私有）
+ 本地方法栈（线程私有）
+ 堆（线程公有）
+ 方法区（线程公有）





<font size=5>**程序计数器（线程私有）**</font>

程序计数器是当前线程所执行字节码的行号指示器，其中存放的内容是字节码指令的地址。



**作用：**

+ 字节码解释器通过改变程序计数器来依次读取指令，从而**实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。

+ 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。【执行中断的时候可以保存位置】



**程序计数器为什么不会出现内存溢出？**

程序计数器只用来存储下一条需要执行的**指令存放的地址**，并且它的大小是在线程创建时一次性完成的，不会动态扩展。

------------------

<font size=5>**虚拟机栈（线程私有）**</font>

每当一个方法被调用时，JVM就会在虚拟机栈中创建一个栈帧（Stack Frame），用于存储与方法相关性信息



**栈帧的组成：**

+ 局部变量表：
  + 存放的内容：this引用（仅实例方法有），方法接收的参数，局部变量。
  + 局部变量表中的slot（槽）是**可以复用**的，一旦某个局部变量不再生效，当前槽就可以被再次使用。
  + 可以存放的数据类型：8种基本数据类型，引用类型（reference，指向对象起始地址，或者指向代表对象的句柄），returnAddress类型的变量
  + 32位之内的类型占用一个slot，64位（long和double）的类型占用两个slot
+ 操作数栈：用于存放方法执行过程中产生的中间计算结果。
+ 动态链接：将程序代码中引用的符号（例如函数、变量等）与其在内存中的实际地址进行关联的过程
+ 方法返回地址

----------------

<font size=5>**本地方法栈（线程私有）**</font>

和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法服务**。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

--------------------

<font size=5>**堆（线程共享）**</font>

此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。【之所以说是几乎所有，是因为从JDK1.7开始，Java会默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，可能会直接在栈上分配内存】



JDK7之前的堆结构：

+ 新生代（Young Generation）
+ 老年代（Old Generation）
+ 永久代（Permanent Generation）



JDK8之后的堆结构：

+ 新生代（Young Generation）
+ 老年代（Old Generation）

永久代被元空间（Metaspace）取代，并且被移入本地内存中



------------------

<font size=5>**方法区（线程共享）**</font>

方法区是一个虚拟概念，**每款Java虚拟机在实现上都各不相同，甚至同一款虚拟机的不同版本之间也存在不同的实现方式**。当虚拟机需要使用一个类的时候，会读取并解析Class文件以获取相关信息，然后将信息存入方法区。【也就是说类的信息会进入方法区，类的实例存储在堆区，不管是自己创建的类还是外部类库中的类都是这样】

例如：HotSpot虚拟机在JDK7中，将方法区存放于永久代空间中，而在JDK8中将方法区存放于元空间中



**方法区在不同版本JDK下的区别：**

+ JDK6：方法区存放在堆的永久代中，字符串常量池存在于方法区中
+ JDK7：方法区存放在堆的永久代中，字符串常量池在堆中但在方法区之外
+ JDK8：方法区改名为元空间，存放在直接内存中，字符串常量池在堆中



**为什么要将永久代替换为元空间？**

+ 永久代在堆中，其本身大小受堆大小的制约；元空间使用的是本地内存，受本机可用内存大小的制约。在元空间中溢出的几率比原来小
+ 永久代的垃圾回收机制一般使用老年代的垃圾回收方式，不够灵活。元空间设计了一套适合方法区的垃圾回收机制。
+ 在JDK8中，HotSpot虚拟机和JRockit虚拟机进行了合并，在JRockit中不存在永久代的概念



堆的大小由虚拟机参数” -XX：MaxPermSize=值“ 来控制

元空间的大小由操作系统” -XX：MaxMetaspaceSize=值“ 来控制

**注意：**

+ 既然元空间的大小是由操作系统来控制的，为什么还要给它设置最大值呢？
+ 在实际应用场景中，服务器上可能有好多个程序同时运行，如果不为程序设置一个元空间大小上限，在出现问题时可能会占用过多内存，从而影响别的程序的运行



**运行时常量池**

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。



**字符串常量池**

JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

需要特别注意的是，JDK1.7之前，方法区是用永久代实现的，此时字符串常量池存在于永久代中。JDK1.7时，字符串常量池和静态变量被移出永久代，存放在堆里。JDK1.8开始，永久代也被彻底取消，方法区通过直接内存中的元空间实现。

之所以将其移入堆中是为了让其更好地被垃圾收集器管理（永久代或者元空间的垃圾回收效率比较低），同时也能减轻永久代和元空间的负担

## 执行引擎



## 本地接口



## 直接内存（不是Java运行时内存区域）

直接内存不由JVM直接管理，它通过在Java代码中调用特定的API从操作系统分配的内存，它的分配和回收不受JVM垃圾回收器的直接控制。

通过“  -XX：MaxDirectMemorySize=值  ” 手动设置直接内存的大小。如果不设置，JVM会自动选择最大分配的大小。



# Java垃圾回收机制

**内存泄漏：**程序中已得到分配的内存得不到有效释放

**内存溢出：**程序运行过程中，尝试分配的内存超过了系统可用的最大内存

Java中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection）机制，通过垃圾回收器来对不再使用的对象完成自动的回收。



**不同垃圾回收方案的优缺点：**

+ **自动垃圾回收**
  + 优点：降低程序员实现难度，降低对象回收bug的可能性
  + 缺点：程序员无法控制垃圾回收的时机
+ **手动垃圾回收**
  + 优点：回收及时性高
  + 缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题



**为什么垃圾回收机制只考虑堆和方法区？**

+ 线程私有的部分会随着线程的创建而创建，线程的销毁而销毁。
+ 栈帧会在方法执行结束后自动弹出栈



## 方法区的回收

方法区的垃圾回收主要关注于卸载类及回收常量池中的常量。

**判定条件：**

+ <font color="red">（自己没有用）</font>在堆中不存在任何该类的实例对象以及子类对象
+ <font color="red">（别人没有用）</font>该类对应的java.lang.Class对象没有在任何地方被引用
+ <font color="red">（不会再加载）</font>加载该类的类加载器已经被回收



## 堆的回收

### 死亡对象判断方法

+ 引用计数法：为每个对象维护一个引用计数器，对象被引用时+1，取消引用时-1
  + 优点：实现简单
  + 缺点：每次引用和取消引用都要维护计数器，影响系统性能；**循环引用**（A引用B，B引用A）时无法回收对象
+ 可达性分析算法：以GC Root对象为根进行搜索，如果一个对象和GC Root之间没有任何引用链相连，就证明该对象不可用，需要被回收



**哪些对象可以被称作GC Root对象？**【不完整】

+ 线程Thread对象。Thread对象中保存了对线程虚拟机栈的引用，虚拟机栈中的栈帧里的局部变量表中又保存了对对象的引用。
+ 系统类加载器加载的java.lang.Class对象。它们可以以静态字段的方式持有对其他对象的引用。
+ 本地接口（JNI，java native interface）调用时使用的全局对象
+ 监视器对象



### 五种对象引用方法

**强引用：**

 Java 中最普通、最常见的引用类型之一。当一个对象被强引用引用时，垃圾回收器不会回收这个对象，即使系统内存不足时也不会回收。只有当所有对该对象的强引用都被解除时，该对象才会成为不可达对象，才会被垃圾回收器回收。



**软引用：SoftReference**

用于在内存紧张时允许垃圾回收器回收对象，通常用于实现对内存敏感的缓存。如果软引用的对象是强可达（被强引用）的，该软引用对象也不会被回收

可以和ReferenceQueue搭配使用。当软引用指向的对象被回收时，SoftReference对象会被放入队列，方便对其进行后续的操作（比如说回收SoftReference对象）

自己的理解：如果堆中存在一个对象，当它被强引用引用时，若内存不足且该引用没有被释放，jvm会报OutOfMemoryError。但是如果这个对象是被软引用引用的，当内存不足时，jvm会释放这个对象，可能就不会报错了。

```Java
//创建一个软引用。referent是软引用指向的对象
public SoftReference(T referent)

//创建一个软引用，并且将其注册到指定的引用队列中
public SoftReference(T referent, ReferenceQueue<? super T> q)
    
//返回该引用所引用的对象，如果对象被回收了就返回null
public T get()
```



**弱引用：WeakReference**

只要对象没有被强引用引用，即使堆内存充足，垃圾回收器也会回收被弱引用引用的对象。

当垃圾回收器进行垃圾回收时，如果**内存不足**才会回收软引用对象。但**无论内存是否足够**，都会回收弱引用引用的对象。

主要在ThreadLocal中使用，平时开发不怎么用。其实现和软引用基本一致。



**虚引用：PhantomReference**

当一个对象只被虚引用所引用时，它随时都可能被垃圾回收器回收，不会影响对象的生存时间。主要用于**跟踪对象被垃圾回收的情况**

通过虚引用对象是无法获得虚引用指向的对象的（它的get方法返回值是个null），它唯一的作用就是当对象被垃圾回收器回收时可以接收到相应的通知



**终结器引用：FinalReference**

终结器引用主要用于管理对象的终结器（Finalizer），确保对象在被垃圾回收器**回收之前能够执行终结器方法**进行资源清理。通常不由用户代码直接创建或使用。



### 垃圾回收器算法

+ **标记-清除算法**：标记存活对象，将没有标记的对象直接清除
  + 优点：简单容易实现
  + 缺点：会产生内存碎片
+ **复制算法**：将内存区域划分成活动区和空闲区，垃圾回收时将存活对象全部移入空闲区。
  + 优点：简单容易实现，不会有内存碎片
  + 缺点：浪费内存，不适合大对象
+ **标记-整理算法**：标记所有存活对象，将存活对象全部移动到一端
  + 优点：解决内存碎片问题
  + 缺点：移动对象开销大，在标记和整理阶段会有较长的STW（stop the world）
+ **分代GC算法**：将堆内存划分为新生代和老年代两个区域。新生代用于存放新创建的对象，而老年代用于存放存活时间较长的对象。
  + 优点：根据不同区域的特点采用不同的垃圾回收策略，这样可以更有效地回收垃圾对象，提高了垃圾回收的效率
  + 缺点： 分代垃圾回收算法会为每个区域分配额外的空间来完成垃圾回收操作，这样可能会导致一定程度的内存浪费。



### 垃圾回收器

#### G1垃圾回收器（JDK8之前还不够成熟）

**区域划分**：G1垃圾回收器将Java堆划分成多个大小相等的区域（区域大小可以手动设置，但必须是2的整数次幂，取值范围为1M~32M），区域大小通常由堆空间大小/2048获得

**回收方式**：

+ 年轻代回收（Young GC）：
  + 新创建的对象存放在Eden区，当G1判断年轻代区不足（max默认60%）时，会执行Young GC。（新创建对象的大小超过Region的一半时会直接放入老年代，被称作Humongous区）
  + 标记出Eden和Survivor区域中存活的对象
  + 根据配置的最大暂停时间**选择某些区域**将存活对象复制到新的Survivor区中（年龄+1）（选择策略：G1会记录回收一个区域的平均耗时，然后根据配置的最大暂停时间计算本次回收的区域数量）
  + 当存活对象的年龄到达阈值时，将其放入老年代。
+ 老年代回收（Mixed GC）：
  + 使用了的内存区域到达阈值（可设置，默认为45%）时触发MixedGC，回收所有年轻代对象和部分老年代对象，以及大对象。
+ Full GC
  + 当清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC，单线程执行标记整理算法，此时会导致用户线程的暂停



# 面试题

## 什么是JVM？

+ JVM的定义

+ JVM的组成：类加载子系统，运行时数据区，执行引擎，本地接口

+ JVM的作用：解释和运行，内存管理，即时编译

  

## 了解过字节码文件的组成吗？

+ 字节码文件是什么
+ 组成：魔数，小版本号，大版本号，【常量池数量，常量池】，访问标记，当前类类名，父类类名，【接口数量，接口】，【字段数量，字段】，【方法数量，方法】，【属性数量，属性】
+ 结尾：工作中一般不查看，但是在对代码性能进行调优时可能要研究，如果要查看，就用javap -v命令查看，或者使用jclasslib插件查看



## 什么是运行时数据区？

+ 什么是运行时数据区：是JVM管理的xxxxxx
+ 运行时数据区的组成：分成线程共享的部分和线程不共享的部分
+ 运行时数据区各部分的功能



## 那些区域会出现内存溢出

+ 内存溢出指的是内存中某一块区域的使用量超过了允许使用的最大值，使用时因空间不足报错，虚拟机会抛出指定错误
+ 栈内存溢出：如果栈大小设置为不可动态调整，则会StackOverFlowError；如果可以动态调整，则会抛出OutOfMemoryError
+ 堆内存溢出：抛出OutOfMemoryError
+ 方法区溢出：元空间溢出或者永久代溢出，抛出OutOfMemoryError
+ 直接内存溢出：申请的直接内存空间大小超过最大值，抛出OutOfMemoryError



## JVM在JDK6-8之间在内存区域上有什么不同

+ 方法区的调整：JDK7及之前的版本将方法区存放在堆中的永久代，JDK8及之后的版本将方法区存放在元空间
+ 字符串常量池的调整：JDK7之前，字符串常量池是运行时常量池的一部分，都存在于永久代中；JDK7字符串常量池被从方法区拿到了堆中；JDK8之后永久代被元空间替代，字符串常量池还在堆中



## 常见的JVM参数

