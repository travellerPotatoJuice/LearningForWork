# HTTP

## 基本概念



## HTTP缓存技术

HTTP有两种常见的缓存技术，强制缓存和协商缓存。当强制缓存无法获得缓存的时候才会启动协商缓存。



**强制缓存：**



**协商缓存：**





## HTTPS

HTTP+SSL/TLS



**HTTP存在的问题：**

+ 明文传输。容易被窃听
+ 没有内容校验机制。不知道内容有没有被篡改。
+ 没有身份校验。不会确认通信的另一方的身份合法性。



**HTTPS的改进：**

+ 混合加密。使信息不会再裸奔。
+ 摘要算法+数字签名。为信息生成指纹，如果信息被篡改就会被发现。
+ 数字证书。将公钥放入数字证书，证明自身合法性。



**混合加密：**

信息安全领域的一种加密方法，同时使用了对称加密和非对称加密。

【什么是对称加密】对称加密是通信双方使用同一把密钥对信息进行加密和解密，加密解密速度比较快，但一旦密钥被拦截，信息就能被第三方破解。

【什么是非对称加密】非对称加密使用两把密钥，私钥仅自己持有，公钥可以任意分发。解密速度比较慢，但是很安全。公钥和私钥都可以对数据进行加密，但是目的不同。公钥加密，私钥解密，是为了确保所传输信息的安全性。私钥加密，公钥解密，是为了确认信息的发送者是私钥的持有者。

【什么是混合加密】混合加密一开始采用非对称加密的方式运送对称加密的密钥，防止其被第三方拦截，安全到达对面。然后接下来的通信就使用对称加密的方法进行了。



**摘要算法**

【摘要算法是什么】发送方利用摘要算法为信息计算一个哈希值，连同着信息一起发送给接收方。接收方收到信息和哈希值后，通过信息计算一个哈希值，如果和发送方提供的哈希值一致，就说明信息没有被篡改。

【为什么要用数字签名】这么做相当于利用哈希值保护信息不被篡改，但哈希值没有被保护，一旦信息+哈希值一起被替换，就检查不出来了。所以要用非对称加密算法保护哈希值。这种通过非对称加密的方法**保护哈希值**的手段就叫做数字签名算法。



**数字证书：**

【数字证书是什么】以上的两种方法都需要基于非对称加密算法实现，所以需要确保获取到的公钥是安全的，是来自通信方的，也就是需要一个身份验证的环节。所以服务器会通过一个权威的机构来对自己进行认证，这个权威的机构会为服务器提供一个证书，也就是数字证书。

【数字证书的怎么证明身份的】服务器会将公钥注册到数字证书认证机构（CA），CA用自己的私钥来保护服务器的公钥，也就是进行数字签名形成一个数字证书，并把这个数字证书提供给服务器。服务器会将这个数字证书发送给客户端，客户端通过CA的公钥对数字证书进行解密以确保数字证书的真实性，然后从中获取到公钥。再利用公钥来加密信息发送给服务器，表明自己已经收到了。

这个地方我是有点疑惑的，因为CA也是用数字签名的方法对服务器的公钥进行加密，也就是说客户端也需要获取到CA的公钥才能对CA用私钥加密过的信息进行解密，那这个获取CA公钥的过程不就和获取服务器端公钥的过程变成一类问题了吗（套娃???？)实际上这里有一个小小的区别，就是CA会提前将公钥内置于服务器中，所以就**不会有CA将公钥传给客户端的过程了**。



【数字证书签发&校验流程】

+ CA将服务器端的各种信息进行打包，并且计算哈希值
+ 用私钥加密哈希值，生成数字签名
+ 将数字签名和服务器端的信息进行打包，形成数字证书



+ 通过哈希算法计算信息部分的哈希值
+ 通过内置在浏览器或者操作系统中的公钥对数字签名部分进行解密，获取CA端计算出的哈希值
+ 比对两个哈希值，如果相同就说明可以信赖。



【数字证书链】客户端持有的公钥是有限的，不可能持有全世界所有CA的公钥，只会持有一部分Root CA的公钥。当客户端收到某个网站的证书时，很有可能发现自己没有这个证书对应的CA的公钥，所以需要查看为CA颁布证书的上一级CA的证书，如果还是很不巧，依然不持有它的公钥，那么就一层一层往上找，一直找到Root CA，再通过Root CA层层往下传递信任。



【为什么要搞数字证书链】如果不搞成这样的链式结构，无非就两种选择。一种是RootCA负责签发所有的证书，这种情况下就会出现”单点故障“，也就是一旦RootCA失守，整个体系就崩盘了。还有一种选择是让客户端存储所有CA的公钥，这显然很不现实，而且扩展性也不好。



----------

TLS 在实现上分为**握手协议**和**记录协议**两层。握手协议用于协商加密算法和生成对称密钥。记录协议负责保护应用程序数据并验证其来源和完整性



**TLS握手协议**

+ 客户端向服务器索要并验证服务器的公钥
+ 双方协商生产会话密钥（也就是对称加密的密钥）
+ 双方采用会话密钥进行通信

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样。常用的密钥交换算法有RSA和ECDHE，以下以RSA算法为例。

+ Client Hello：客户端发送其支持的TLS版本，以及随机数（Client Random），还有它支持的密码套件列表（比如RSA）

+ Server Hello：服务器确认TLS版本，服务器生成的随机数（Server Random），确认密码套件列表，服务器的数字证书

+ 客户端回应：客户端确认过证书的有效性，从整数中获取到服务器的公钥。然后生成一个随机数（pre-master key），加密算法改变通知（表示接下来的通信要用会话密钥加密了），握手结束通知。将以上三个东西通过摘要算法计算哈希值，用公钥加密，发送给服务器端

  【客户端发送完随机数后，双方此时都持有了三个随机数，就可以用协商的加密算法和这三个随机数生成会话密钥了】

+ 服务器算出了会话密钥，发送加密算法改变通知，握手结束通知

基于 RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的是 ECDHE 密钥协商算法



**TLS记录协议**



# TCP



# IP

