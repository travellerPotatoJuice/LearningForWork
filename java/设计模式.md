# 概述

## 设计模式分类

+ 创建型模式
  + 单例
  + 原型
  + 工厂方法
  + 抽象工厂
  + 建造者
+ 结构型模式
  + 代理
  + 适配器
  + 桥接
  + 装饰
  + 外观
  + 享元
  + 组合
+ 行为型模式
  + 模板方法
  + 策略
  + 命令
  + 职责链
  + 状态
  + 观察者
  + 中介者
  + 迭代器
  + 访问者
  + 备忘录
  + 解释器



## 类图

类图是统一建模语言（Unified Modeling Language，UML）中的一种图，UML是用于设计软件的可视化建模语言，分为用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图



<font size=5>**关联关系**</font>

用于表示一类对象与另一类对象之间的联系。分为一般关联关系，聚合关系和组合关系



**一般关联关系**

+ 单向关联：一个类持有另一个类类型的成员变量。Customer类持有一个Address类的对象，Customer所持有的Address对象无法独立存在。

![1718721504941](images\1718721504941.png)

+ 双向关联：双方各自持有对方类型的成员变量。Customer类持有一个Product类型的对象（此处表现为List形式），Product持有一个Customer类型的对象

  ![1718721626856](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721626856.png)

+ 自关联：类持有自身类型的成员变量。

  ![1718721719284](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721719284.png)



**聚合关系**

是整体和部分之间的关系。成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。

例如，学校包含老师，但如果老师停办了，老师依然存在

![1718721770654](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721770654.png)



**组合关系**

是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。

![1718722129835](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722129835.png)



<font size=5>**依赖关系**</font>

是对象之间耦合度最低的一种关系。在代码中，某个类的方法通过局部变量、方法的参数，或者对静态方法的调用来访问另一个类中的某些方法来完成一些职责，就被称为依赖关系。

![1718722365704](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722365704.png)



<font size=5>**继承关系**</font>

是对象之间耦合度最大的一种关系。

![1718722536449](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722536449.png)



<font size=5>**实现关系**</font>

实现关系是接口与实现类之间的关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有抽象操作。

![1718722665826](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722665826.png)



## 设计原则

<font size=5>**1.开闭原则**</font>

**对扩展开放，对修改关闭**。在程序需要扩展时不能修改现有代码，要实现一个热插拔的效果。

开闭原则的关键在于通过**抽象化**和**多态**来实现代码的扩展性，例如使用接口、抽象类、依赖注入等技术。通过这些手段，可以使得软件系统在面对新需求时能够以最小的代价进行扩展，而不必修改现有的代码。



<font size=5>**2.里氏代换原则**</font> 

任何父类出现的地方，子类都可以出现。通俗地说：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

通过重写父类的方法来完成新的功能，写起来虽然简单，但是整个继承体系的可复用性较差，程序运行出错的概率也会变大。  



<font size=5>**3.依赖倒转原则**</font>

高层模块不应该依赖于底层模块，它们都应该依赖于抽象。抽象不应该依赖于具体细节，具体实现细节应该依赖于抽象。



<font size=5>**4.接口隔离原则**</font>

客户端不应该被迫依赖于它不使用的方法，**一个类对另一个类的依赖应该建立在最小的接口上**。

接口隔离原则的主要目的是通过设计精细的接口，提高系统的内聚性（一个接口只服务于一个功能模块），减少耦合性（客户端只依赖于需要的接口），从而使得系统更加灵活、可维护和可扩展。

总结来说，接口隔离原则鼓励我们**设计一些小而专一的接口**，避免设计臃肿的接口，从而提高代码的灵活性和可维护性。



<font size=5>**5.迪米特法则**</font>

又叫最少知识原则，它的核心思想是**一个对象应当对其他对象有尽可能少的了解，不应该直接与陌生对象发生相互作用**，而是通过自己的朋友（即直接依赖的对象）来完成任务。

朋友指的是：该对象本身，被当作方法参数传入的对象，此方法创建或实例化的对象，对象的组件对象。



<font size=5>**6.合成复用原则**</font>

它强调在系统设计中应**优先使用对象组合（合成）而不是继承来达到复用的目的**。该原则的核心思想是通过将现有的类组合而成新的类，而不是通过继承现有的类来获得新的功能。

**类的复用可以分为继承复用和合成复用**。继承复用简单易实现，但也存在以下缺点：

1. 继承破坏了类的封装性。继承会将父类的细节暴露给子类，这种复用称为“白箱”复用
2. 子类和父类的耦合度高。父类的任何改变都会导致子类的实现发生变化。
3. 限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时就定义了，运行时不能发生变化。

合成复用有以下优点：

1. 维持了类的封装性。成员对象的内部细节不可见，这种复用称为“黑箱”复用
2. 对象间的耦合度低。可以在类的成员位置声明抽象。
3. 复用的灵活性高。这种复用可以在运行时动态进行。