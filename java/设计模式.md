# 概述

## 设计模式分类

+ 创建型模式
  + 单例模式（单一实例）
  + 工厂方法模式（多种产品）
  + 抽象工厂模式（产品族）
  + 原型模式（复制实例）
  + 建造者模式
+ 结构型模式
  + 代理模式
  + 适配器模式
  + 桥接模式
  + 装饰模式
  + 外观模式
  + 享元模式
  + 组合模式
+ 行为型模式
  + 模板方法模式
  + 策略模式
  + 命令模式
  + 职责链模式
  + 状态模式
  + 观察者模式
  + 中介者模式
  + 迭代器模式
  + 访问者模式
  + 备忘录模式
  + 解释器模式



## 类图

类图是统一建模语言（Unified Modeling Language，UML）中的一种图，UML是用于设计软件的可视化建模语言，分为用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图



<font size=5>**关联关系**</font>

用于表示一类对象与另一类对象之间的联系。分为一般关联关系，聚合关系和组合关系



**一般关联关系**

+ 单向关联：一个类持有另一个类类型的成员变量。Customer类持有一个Address类的对象，Customer所持有的Address对象无法独立存在。

![1718721504941](images\1718721504941.png)

+ 双向关联：双方各自持有对方类型的成员变量。Customer类持有一个Product类型的对象（此处表现为List形式），Product持有一个Customer类型的对象

  ![1718721626856](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721626856.png)

+ 自关联：类持有自身类型的成员变量。

  ![1718721719284](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721719284.png)



**聚合关系**

是整体和部分之间的关系。成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。

例如，学校包含老师，但如果老师停办了，老师依然存在

![1718721770654](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721770654.png)



**组合关系**

是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。

![1718722129835](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722129835.png)



<font size=5>**依赖关系**</font>

是对象之间耦合度最低的一种关系。在代码中，某个类的方法通过局部变量、方法的参数，或者对静态方法的调用来访问另一个类中的某些方法来完成一些职责，就被称为依赖关系。

![1718722365704](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722365704.png)



<font size=5>**继承关系**</font>

是对象之间耦合度最大的一种关系。

![1718722536449](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722536449.png)



<font size=5>**实现关系**</font>

实现关系是接口与实现类之间的关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有抽象操作。

![1718722665826](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722665826.png)



## 设计原则

<font size=5>**1.开闭原则**</font>

**对扩展开放，对修改关闭**。在程序需要扩展时不能修改现有代码，要实现一个热插拔的效果。

开闭原则的关键在于通过**抽象化**和**多态**来实现代码的扩展性，例如使用接口、抽象类、依赖注入等技术。通过这些手段，可以使得软件系统在面对新需求时能够以最小的代价进行扩展，而不必修改现有的代码。



<font size=5>**2.里氏代换原则**</font> 

任何父类出现的地方，子类都可以出现。通俗地说：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

通过重写父类的方法来完成新的功能，写起来虽然简单，但是整个继承体系的可复用性较差，程序运行出错的概率也会变大。  



<font size=5>**3.依赖倒转原则**</font>

高层模块不应该依赖于底层模块，它们都应该依赖于抽象。抽象不应该依赖于具体细节，具体实现细节应该依赖于抽象。



<font size=5>**4.接口隔离原则**</font>

客户端不应该被迫依赖于它不使用的方法，**一个类对另一个类的依赖应该建立在最小的接口上**。

接口隔离原则的主要目的是通过设计精细的接口，提高系统的内聚性（一个接口只服务于一个功能模块），减少耦合性（客户端只依赖于需要的接口），从而使得系统更加灵活、可维护和可扩展。

总结来说，接口隔离原则鼓励我们**设计一些小而专一的接口**，避免设计臃肿的接口，从而提高代码的灵活性和可维护性。



<font size=5>**5.迪米特法则**</font>

又叫最少知识原则，它的核心思想是**一个对象应当对其他对象有尽可能少的了解，不应该直接与陌生对象发生相互作用**，而是通过自己的朋友（即直接依赖的对象）来完成任务。

朋友指的是：该对象本身，被当作方法参数传入的对象，此方法创建或实例化的对象，对象的组件对象。



<font size=5>**6.合成复用原则**</font>

它强调在系统设计中应**优先使用对象组合（合成）而不是继承来达到复用的目的**。该原则的核心思想是通过将现有的类组合而成新的类，而不是通过继承现有的类来获得新的功能。

**类的复用可以分为继承复用和合成复用**。继承复用简单易实现，但也存在以下缺点：

1. 继承破坏了类的封装性。继承会将父类的细节暴露给子类，这种复用称为“白箱”复用
2. 子类和父类的耦合度高。父类的任何改变都会导致子类的实现发生变化。
3. 限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时就定义了，运行时不能发生变化。

合成复用有以下优点：

1. 维持了类的封装性。成员对象的内部细节不可见，这种复用称为“黑箱”复用
2. 对象间的耦合度低。可以在类的成员位置声明抽象。
3. 复用的灵活性高。这种复用可以在运行时动态进行。



# 创建型模式

## 单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，其主要目的是确保**类只有一个实例**，**并提供一个全局访问点**。这种模式通常在需要控制资源使用或者确保全局唯一性的场景下使用。



**应用场景**：

+ Spring框架。每个Bean实例在Spring框架中默认只有一个。
+ JDK的`Runtime`运行时环境。`Runtime.getRuntime()`可以获取Runtime类的唯一实例，用于与操作系统进行交互(最简单的饿汉式实现方式，可以通过反射破坏)
+ 资源共享。多个客户端共享同一资源，如数据库连接池、线程池等。
+ 配置管理。全局的配置信息可以使用单例模式来管理。



**分类：**

+ 饿汉式（Eager Initialization）

  + 类加载时就创建实例，确保多线程环境下也能正确实现单例
  + 会造成资源的浪费，因为即使没有使用该实例，也会创建
+ 懒汉式（Lazy Initialization）

  + 首次使用时创建实例，延迟初始化
  + 可以节约资源，但是需要考虑线程安全问题。




**破坏单例模式：**

+ 序列化与反序列化

  + 反序列化构造对象时绕过了类的构造方法和静态变量，直接从序列化数据中创建对象
  + 可以通过实现`readResolve()`方法来解决。该方法会在调用`readObject()`读取对象时返回`readResolve()`所定义的返回值

+ 反射

  + 通过反射获取私有的构造方法并创建对象
  + 可以在构造函数中增加对对象的判断

  



## 工厂模式

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的最佳方式，目的是在不暴露对象创建逻辑的前提下，允许使用者统一请求创建对象的接口。简单来说就是如果在创建对象的时候直接通过new来创建，就会导致类与类之间存在严重的耦合。通过工厂可以实现客户端和类解耦合。

值得注意的是，通过工厂类获取对象虽然会导致工厂类和对象类出现耦合，但这比客户端和对象类之间的耦合更加可控。



**应用场景：**

+ Spring 框架。 `FactoryBean` 接口允许定义自定义的工厂类，用来创建特定类型的 Bean 实例。
+ JDK源码。`Collections`是抽象工厂类，`ArrayList`是具体工厂类。`Iterator`是抽象产品，`Itr`是具体产品类（在`ArrayList`内部创建）。
+ JDK源码。`DateFormat`类中调用`Calendar`类的`getInstance`方法获取`Calendar`对象



**分类：**

- 简单工厂模式（Simple Factory Pattern）

  - 实际上不属于23种设计模式中的一种，而是一种编程习惯
  - 增加新对象时还是需要修改工厂类的代码

- 工厂方法模式（Factory Method Pattern）

  - 将创建子类的工作下放到了具体工厂中
  - 相对于简单工厂模式来说，更加灵活和扩展性强，但会**导致出现更多的类和代码**。

  

## 抽象工厂模式

抽象工厂模式关注于创建一系列相关对象的产品族。

**产品族**：抽象工厂模式强调一系列相关的产品对象的创建，这些产品对象之间具有一定的关联性，例如，在不同的操作系统下，按钮、文本框等 UI 组件的组合和风格可能会有所不同。

总的来说，抽象工厂模式和工厂方法模式没有本质上的区别，当抽象工厂模式下需要创建新的产品族，工厂方法模式下需要创建新的产品时，都需要创建一个新的具体工厂类。

抽象工厂模式的优点在于，它能保证客户端始终只使用同一个产品族中的对象。它的缺点在于，当产品族种要增加产品时，所有的工厂类都需要修改。



**应用场景：**

+ 系统中有多个产品族，但每次都只使用某一族的产品。比如切换皮肤等。

  



**模式扩展：**







## 原型模式

原型模式就是**通过复制现有对象来创建新对象**，而不是通过实例化的方式。这种模式允许我们通过复制现有对象的原型来创建新对象，而无需知道其具体的创建细节。

原型模式的克隆分为浅克隆和深克隆。

**浅克隆**：仅复制对象本身，而**不复制对象引用的成员变量**。

**深克隆**：除了复制对象本身外，还递**归地复制对象引用的所有成员变量**。



**应用场景：**

+ 对象创建过程非常复杂时，可以用原型模式快速创建。







## 建造者模式

将一个复杂对象的构建和表示分离，使得同样的构建过程可以构建不同的表示。由于实现了构建和装配的解耦，不同的构建器，相同的装配，也可以做出不同的对象。

强调的是**装配的过程**，不是各个部件的具体构造方法。



**优点与缺点：**

+ **优点**：
  + **分步构建复杂对象**。 建造者模式将复杂对象的构建过程拆分成多个步骤，使得构建过程更加灵活，能够更精确地控制每一步的细节。
  + **隐藏构建细节**。客户端不需要知道对象的构建细节，只需通过指定建造者的步骤来构建对象，使得客户端代码与具体对象的构建过程解耦。
  + **容易扩展**。如果有新的需求，直接创建一个新的建造者类即可。
+ **缺点**：
  + **不适合创建简单对象：** 对于简单的对象，使用建造者模式可能会显得繁琐。
  + **对象内部状态变化较复杂：** 如果对象内部状态变化频繁，或者有较多的可选属性，可能需要定义多个具体建造者来实现不同的构建逻辑，增加了复杂性。



**应用场景：**

+ 产品各部分经常变化，但是组合的算法比较稳定
+ JDK。`StringBuilder`和`StringBuffer`，append(), insert()等方法
+ JDK。`ProcessBuilder`



**模式扩展：**

+ **链式调用**。通过让建造者的方法返回当前建造者对象（通常是自身），使得可以连续调用多个方法，形成一条“链”。这种方式可以使代码更加清晰和流畅，增强了可读性。







# 结构型模式

结构型模式是一类专注于如何组合类和对象形成更大结构的设计模式，它们主要解决的是对象之间的组合关系，使得系统更加灵活、可复用和易于理解，可分为**类结构型模式**和**对象结构型模式**。



------------------

## 代理模式

代理模式（Proxy Pattern）的主要目的是通过创建一个代理对象来控制对其它对象的访问。代理对象可以在访问对象时添加额外的功能，同时不改变原始对象的代码。

Java中的代理按照代理类的生成时机不同，可以分为**静态代理模式**和**动态代理模式**，动态代理又分为**JDK代理**和**CGLib代理**两种。



**结构：**

+ 抽象主题类（Subject）：通过接口或抽象类声明真实主题和代理对象实现的业务方法
+ 真实主题类（Real Subject）：实现抽象主题中的业务，是代理对象所代表的真实对象，是最终要引用的对象
+ 代理类（Proxy）：提供与真实主题相同的接口，用于访问、控制、扩展真是主题的功能。





**分类：**

+ 静态代理
  + 手动编写的代理类，对于每一个被代理类，都需要为其创建一个代理类
  + 形成的代理关系在编译时确定
+ 动态代理
  + JDK代理：基于`java.lang.reflect.Proxy`类和'`InvocationHandler`'接口
    + 代理对象的行为由`InvocationHandler`的实现类在运行时决定。
    + `ProxyFactory`只是一个工厂方法，并不是真正的代理类，代理类是在运行过程中动态地生成的。
    + 在运行过程中，代理类会将传入的'`InvocationHandler`'传递给父类（Proxy类）
  + `CGLib`代理：



**优点与缺点：**

- **优点**：
  - 扩展目标用户的功能
  - 将客户端与目标对象分离，在一定程度上降低了耦合度
- **缺点**：
  - 增加系统的复杂度



**应用场景：**

+ 远程代理
+ 防火墙代理
+ 保护代理：可以给不同的用户提供不同级别的用户权限



----------------------

## 适配器模式

适配器模式通过一个适配器对象**将一个类的接口转换成客户希望的另一个接口**，使得原本由于接口不兼容而不能一起工作的两个类可以一起工作。



**分类**：

+ 类适配器模式
  + 适配器类实现了目标接口，继承了被适配者类，从而可以直接访问被适配者的方法和属性
  + 这种方法中适配器和被适配者的耦合性较强，且无法适配多个被适配者类
+ 对象适配器模式
  + 适配器类实现了目标接口，聚合了被适配者类，通过聚合的被适配者类对象访问对应的方法
  + 用组合代替了继承，提高了适配器类的灵活度，降低了耦合度，避免了继承的各种缺点。



**优点与缺点：**

- **优点**：

  - 提高兼容性。让因为接口不兼容而不同一起工作的类可以协同工作。
  - 重用现有功能。无需修改原有代码，使原有代码和其他系统组件协同工作

- **缺点**：

  - 过多适配器类增加系统的复杂度

    

**应用场景：**

- 旧系统改造。系统升级改造时，如果需要用到旧系统的组件，适配器模式可以帮助新旧系统进行适配。
- 使用第三方组件。第三方组件定义的接口和自己要求的接口定义不同。
- JDK。字符流和字节流的转换，`Reader`和`InputStream`的适配使用的是`InputStreamReader`



------------------------------

## 装饰者模式 

装饰者模式允许向现有对象动态地添加额外的功能，同时又不改变其结构。这种模式的作用是在**不修改现有对象的基础上，动态地添加功能**，使得功能的扩展更加灵活。



**结构：**

- 抽象构件角色（Component）：用于规范准备接收附加责任的对象
- 具体构件角色（Concrete Component）：实现抽象构建，通过装饰角色为其添加一些职责
- 抽象装饰角色（Decorator）：继承或实现抽象构件，包含具体构件的实例，通过其子类扩展具体构件的功能
- 具体装饰角色（Concrete Component）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任



**优点与缺点：**

- **优点**：

  - 提供比继承更灵活的扩展功能。可以动态地向对象添加功能，通过装饰者可以在不改变原有对象结构的情况下，灵活地添加新的行为。
  - 装饰者类和被装饰类可以独立发展，不相互耦合

  

**应用场景：**

- 不能用继承对系统进行扩充时。
  - 系统中存在大量独立扩展，如果要支持所有组合会产生很多很多子类
  - 类定义不能继承时（如被final修饰）
- 当对象的功能要求可以动态地添加，也可以动态地撤销
- JDK。IO流中的`BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`等.



装饰者模式和静态代理模式具有一定的相似之处，其区别如下：

+ 目的不同

  + 装饰者是为了**增强**目标对象
  + 静态代理是为了**隐藏**目标对象

+ 目标对象构建的地方不同

  + 装饰者需要从外界获取具体的对象
  + 静态代理在代理类内部创建对象

  

----------------------------------

## 桥接模式

桥接模式用于将抽象部分与实现部分分离，从而使它们可以独立变化。桥接模式通过将抽象和实现解耦，使得它们可以独立地进行扩展，而不会相互影响，同时还能保持功能的一致性。



**结构：**

- 抽象化（Abstraction）：抽象类接口，包含一个对实现化对象的引用
- 扩展抽象化（Refined Abstraction）：抽象化的子类，实现父类中的业务方法，通过组合关系调用实现化角色中的业务方法
- 实现化（Implementor）：定义实现类的接口，供扩展抽象化角色调用
- 具体实现化（Concrete Implementor）：给出实现化角色接口的实现



**优点与缺点：**

- **优点**：

  - 扩展性。提高了系统扩展性，可以在两个维度分别扩展而不影响其他维度。
  - 实现细节对客户透明

  

**应用场景：**

- 一个类存在两个独立变化的维度，且两个维度都需要扩展时。
- 系统不希望使用继承，或因为多层次继承导致系统类的个数急剧增加时。（维度1有m种，维度2有n种基于继承实现就需要m*n种，而桥接模式只需要m+n）



------------------------------------

## 外观模式

外观模式提供了一个统一的接口，用来访问子系统中的一群接口，且无需了解子系统的实现细节，从而使得子系统更易于使用。



**结构：**

- 外观角色（Facade）：为多个子系统提供对外的共同接口
- 子系统角色（Sub System）：实现系统的部分功能供外观角色调访问



**优点与缺点：**

- **优点**：

  - 对用户屏蔽了子系统组件，减少了客户处理的对象个数，降低系统使用难度

- **缺点**：

  - 不符合开闭原则，修改起来很麻烦

  

**应用场景：**

- 构建分层结构系统。简化子系统之间的依赖关系
- 子系统很多。外观模式可以为系统设计一个简单的接口供外界访问。
- 客户端与多个子系统间存在联系。外观模式可以将他们分离，从而提高子系统的独立性和可移植性
- Tomcat。`RequestFacade`定义了私有成员变量Request，通过外观模式实现资源屏蔽



-----------------------------------

## 组合模式

将对象组**合成树形结构**来表现“整体-部分”的层次结构。组合模式使得客户端可以统一对待单个对象和对象组合，因此对于树形结构的处理变得更加简单和统一。



**结构：**

- 抽象根节点（Component）：定义了组合中所有对象的共有方法，并可实现一些默认的行为。
- 容器结点（Composite）：可以包含其他组件（叶子节点或其他容器节点），并实现在组合中管理子对象的方法
- 叶子节点（Leaf）：是系统层次遍历的最小单位



**分类：**

+ 透明组合模式
  + 抽象构件角色中**声明了所有用于管理成员对象的方法**，无需区分叶子节点和容器节点
  + 客户端层面使用简单，统一了叶子节点和容器节点的接口，但由于叶子节点和容器节点实际上拥有的方法不一样，编译时不会出现错误，但使用时有可能抛出异常
+ 安全组合模式
  + 抽象构件角色中**不声明管理子对象的方法**，而是在容器构件角色中声明和实现这些方法。叶子构件角色不实现这些管理子对象的方法。
  + 接口清晰，各角色的责任明确，但客户端需要分别对待叶子节点和容器节点，使用稍微复杂一些。



**优点与缺点：**

- **优点**：

  - 可以统一对待单个对象和组合对象，无需区分叶子节点和容器节点
  - 可以轻松地定义层次结构，并且灵活地添加叶子结点和容器结点

- **缺点**：

  - 组合模式适合于表示部分-整体层次结构，但对于不需要这种层次结构的情况，引入组合模式可能会增加不必要的复杂性。

  

**应用场景：**

- 递归结构。例如树形结构等。
- 需要对处理对象和对象组合进行统一的处理。



------------------

## 享元模式

通过共享已经存在的对象来减少需要创建的对象数量，避免大量相似对象的创建，从而提高系统资源的利用率。

享元中存在以下两种状态：

+ 内部状态：不会随着环境的改变而改变的可共享部分。
+ 外部状态：会随着环境改变而改变的不可共享部分。





**结构：**

- 抽象享元（Flyweight）：通过这个接口享元对象可以接受并作用于外部状态。通常包含一个操作方法，该方法的参数就是外部状态，通过外部状态来改变享元对象的行为。
- 具体享元（Concrete Flyweight）：实现了抽象享元类定义的接口或者抽象类。具体享元类中通常包含了**内部状态**（可以被多个对象共享的状态）和**外部状态**（不可共享的状态）。
- 非享元（Unsharable Flyweight）：在某些情况下，有些**享元对象的内部状态不能被共享**，或者是不适合共享的。这种情况下可以创建非享元对象，它们通常不会被享元工厂管理，而是由客户端直接创建和使用。
- 享元工厂（Flyweight Factory）：当客户请求享元对象时，由享元工厂提供



**优点与缺点：**

- **优点**：

  - 减少相似的对象的创建，节约资源，提升系统性能
  - 享元模式的外部状态相对独立，不影响内部状态

- **缺点**：

  - 需要分离内部外部状态，程序逻辑复杂
  - 高并发环境下需要考虑共享安全的问题

  

**应用场景：**

- 应用程序需要大量相似对象，且在系统运行过程中需要多次重复使用。
- 对象的大部分状态都可以外部化，并且可以将外部状态传递到对象中
- JDK。`Integer`类中，对`num (-128<=num<127)`间的数字默认创建`Integer对象`进行存储，如果获取这个区段的Integer对象，每次都会获得同一个。如果获取的Integer不在这个区段内，会创建新对象。



------------------



# 行为型模式

行为型模式主要关注对象之间的通信和职责分配，它们涉及到对象如何互相协作以完成更大范围的任务。

主要可以分为**类行为模式**和**对象行为模式**。类行为模式采用继承机制在类之间分派行为，对象行为模式通过组合或者聚合在对象间分配行为。由于组合和聚合比继承关系的耦合度低，所有对象行为模式具有更高的灵活度。



## 模板方法模式

模板方法模式定义了一个算法中的算法骨架，将一些步骤延迟到子类中实现，使得子类可以在不改变该算法结构的情况下重定义该算法的某些特定步骤





**结构：**

- 抽象类（Abstract Class）：负责给出算法的轮廓和骨架，由一个**模板方法**和若干个**基本方法**构成
  - 模板方法：定义算法骨架，按某种顺序调用其包含的基本方法
  - 基本方法：实现算法各个步骤的方法，是模板方法的组成部分
    - 抽象方法（Abstract Method）：在抽象类中声明但没有具体实现的方法，由子类去实现。（特有）
    - 具体方法（Concrete Method）：直接实现的具体步骤，通常是共享的或者对所有子类都相同的（共性）
    - 钩子方法（Hook Method）：子类可以选择性地覆盖这些方法来影响算法的行为。
- 具体子类（Concrete Class）：实现抽象类中定义的抽象方法和钩子方法





**优点与缺点：**

- **优点**：

  - **提高了代码复用性**。相同的代码放在父类里，不同的代码放在不同的子类中。
  - **实现反向控制**。通常都是在子类中调用父类的方法，此处实现了父类对子类的控制。

- **缺点**：

  - 类的数量太多。不同实现都需要各自定义一个子类，导致类的个数增加，系统变得庞大
  - 反向控制提高了代码阅读难度。父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，导致出现了返乡的控制，提高了代码阅读的难度

  

**应用场景：**

- 算法的整体架构比较稳定，个别部分易变。
- 需要通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。
- JDK。`InputStream`类中定义了多个read()方法，在其中一个read()方法中调用了抽象方法read()，这个方法最终会由子类实现



## 策略模式





## 命令模式





## 责任链模式





## 状态模式





## 观察者模式





## 中介者模式





## 迭代器模式





## 访问器模式

