# 概述

## 设计模式分类

+ 创建型模式
  + 单例
  + 原型
  + 工厂方法
  + 抽象工厂
  + 建造者
+ 结构型模式
  + 代理
  + 适配器
  + 桥接
  + 装饰
  + 外观
  + 享元
  + 组合
+ 行为型模式
  + 模板方法
  + 策略
  + 命令
  + 职责链
  + 状态
  + 观察者
  + 中介者
  + 迭代器
  + 访问者
  + 备忘录
  + 解释器



## 类图

类图是统一建模语言（Unified Modeling Language，UML）中的一种图，UML是用于设计软件的可视化建模语言，分为用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图



<font size=5>**关联关系**</font>

用于表示一类对象与另一类对象之间的联系。分为一般关联关系，聚合关系和组合关系



**一般关联关系**

+ 单向关联：一个类持有另一个类类型的成员变量。Customer类持有一个Address类的对象，Customer所持有的Address对象无法独立存在。

![1718721504941](images\1718721504941.png)

+ 双向关联：双方各自持有对方类型的成员变量。Customer类持有一个Product类型的对象（此处表现为List形式），Product持有一个Customer类型的对象

  ![1718721626856](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721626856.png)

+ 自关联：类持有自身类型的成员变量。

  ![1718721719284](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721719284.png)



**聚合关系**

是整体和部分之间的关系。成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。

例如，学校包含老师，但如果老师停办了，老师依然存在

![1718721770654](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718721770654.png)



**组合关系**

是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。

![1718722129835](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722129835.png)



<font size=5>**依赖关系**</font>

是对象之间耦合度最低的一种关系。在代码中，某个类的方法通过局部变量、方法的参数，或者对静态方法的调用来访问另一个类中的某些方法来完成一些职责，就被称为依赖关系。

![1718722365704](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722365704.png)



<font size=5>**继承关系**</font>

是对象之间耦合度最大的一种关系。

![1718722536449](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722536449.png)



<font size=5>**实现关系**</font>

实现关系是接口与实现类之间的关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有抽象操作。

![1718722665826](C:\Users\chygo\Desktop\LearningForWork\Java\images\1718722665826.png)



## 设计原则

<font size=5>**1.开闭原则**</font>

**对扩展开放，对修改关闭**。在程序需要扩展时不能修改现有代码，要实现一个热插拔的效果。

开闭原则的关键在于通过**抽象化**和**多态**来实现代码的扩展性，例如使用接口、抽象类、依赖注入等技术。通过这些手段，可以使得软件系统在面对新需求时能够以最小的代价进行扩展，而不必修改现有的代码。



<font size=5>**2.里氏代换原则**</font> 

任何父类出现的地方，子类都可以出现。通俗地说：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

通过重写父类的方法来完成新的功能，写起来虽然简单，但是整个继承体系的可复用性较差，程序运行出错的概率也会变大。  



<font size=5>**3.依赖倒转原则**</font>

高层模块不应该依赖于底层模块，它们都应该依赖于抽象。抽象不应该依赖于具体细节，具体实现细节应该依赖于抽象。



<font size=5>**4.接口隔离原则**</font>

客户端不应该被迫依赖于它不使用的方法，**一个类对另一个类的依赖应该建立在最小的接口上**。

接口隔离原则的主要目的是通过设计精细的接口，提高系统的内聚性（一个接口只服务于一个功能模块），减少耦合性（客户端只依赖于需要的接口），从而使得系统更加灵活、可维护和可扩展。

总结来说，接口隔离原则鼓励我们**设计一些小而专一的接口**，避免设计臃肿的接口，从而提高代码的灵活性和可维护性。



<font size=5>**5.迪米特法则**</font>

又叫最少知识原则，它的核心思想是**一个对象应当对其他对象有尽可能少的了解，不应该直接与陌生对象发生相互作用**，而是通过自己的朋友（即直接依赖的对象）来完成任务。

朋友指的是：该对象本身，被当作方法参数传入的对象，此方法创建或实例化的对象，对象的组件对象。



<font size=5>**6.合成复用原则**</font>

它强调在系统设计中应**优先使用对象组合（合成）而不是继承来达到复用的目的**。该原则的核心思想是通过将现有的类组合而成新的类，而不是通过继承现有的类来获得新的功能。

**类的复用可以分为继承复用和合成复用**。继承复用简单易实现，但也存在以下缺点：

1. 继承破坏了类的封装性。继承会将父类的细节暴露给子类，这种复用称为“白箱”复用
2. 子类和父类的耦合度高。父类的任何改变都会导致子类的实现发生变化。
3. 限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时就定义了，运行时不能发生变化。

合成复用有以下优点：

1. 维持了类的封装性。成员对象的内部细节不可见，这种复用称为“黑箱”复用
2. 对象间的耦合度低。可以在类的成员位置声明抽象。
3. 复用的灵活性高。这种复用可以在运行时动态进行。



# 创建型模式

## 单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，其主要目的是确保**类只有一个实例**，**并提供一个全局访问点**。这种模式通常在需要控制资源使用或者确保全局唯一性的场景下使用。



**应用场景**：

+ Spring框架。每个Bean实例在Spring框架中默认只有一个。
+ JDK的`Runtime`运行时环境。`Runtime.getRuntime()`可以获取Runtime类的唯一实例，用于与操作系统进行交互(最简单的饿汉式实现方式，可以通过反射破坏)
+ 资源共享。多个客户端共享同一资源，如数据库连接池、线程池等。
+ 配置管理。全局的配置信息可以使用单例模式来管理。



**分类：**

+ 饿汉式（Eager Initialization）

  + 类加载时就创建实例，确保多线程环境下也能正确实现单例
  + 会造成资源的浪费，因为即使没有使用该实例，也会创建
+ 懒汉式（Lazy Initialization）

  + 首次使用时创建实例，延迟初始化
  + 可以节约资源，但是需要考虑线程安全问题。




**破坏单例模式：**

+ 序列化与反序列化

  + 反序列化构造对象时绕过了类的构造方法和静态变量，直接从序列化数据中创建对象
  + 可以通过实现`readResolve()`方法来解决。该方法会在调用`readObject()`读取对象时返回`readResolve()`所定义的返回值

+ 反射

  + 通过反射获取私有的构造方法并创建对象
  + 可以在构造函数中增加对对象的判断

  



## 工厂模式

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的最佳方式，目的是在不暴露对象创建逻辑的前提下，允许使用者统一请求创建对象的接口。简单来说就是如果在创建对象的时候直接通过new来创建，就会导致类与类之间存在严重的耦合。通过工厂可以实现客户端和类解耦合。

值得注意的是，通过工厂类获取对象虽然会导致工厂类和对象类出现耦合，但这比客户端和对象类之间的耦合更加可控。



**应用场景：**





**分类：**

- 简单工厂模式（Simple Factory Pattern）

  - 实际上不属于23种设计模式中的一种，而是一种编程习惯
  - 增加新对象时还是需要修改工厂类的代码

- 工厂方法模式（Factory Method Pattern）

  - 将创建子类的工作下放到了具体工厂中
  - 相对于简单工厂模式来说，更加灵活和扩展性强，但会**导致出现更多的类和代码**。

  

## 抽象工厂模式

 **应用场景：**



**分类：**







# 结构型模式







# 行为型模式

