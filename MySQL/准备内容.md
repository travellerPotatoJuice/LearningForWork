# 什么是事务？为什么要有隔离等级？解决了什么问题？

+ 事务是一组满足ACID特性的操作，A是原子性，C是一致性，I是隔离性，D是持久性

+ 事务之间并发执行，会出现脏读、不可重复读、幻读的问题。通过不同的隔离等级，可以有效地解决这些问题。

  

# 隔离等级的实现方式

+ 主要就是通过(read_view+MVCC),以及读写锁来实现
+ 读未提交：直接读取最新数据
+ 读提交：每次读取数据时生成一个read view。
  + 数据都有隐藏字段，用于记录最后一次对该数据进行修改的事务号，以及指向上一版本数据的指针。
  + read view里包含当前活跃事务，活跃事务中的最小编号，创建read view时要分配给下一个事务的编号。
  + 如果大于下一个事务编号，不可见。若小于最小编号，可见。如果在最小编号和下一事务编号之间，且不在活跃事务中，可见，否则就不可见。
  + 沿着undo链一直找到满足要求的版本
+ 可重复读：事务开启前生成read view。
  + 只有生成read view的时机不同，其余都相同。
+ 串行化：加读写锁



# 什么是快照读，什么是当前读？

+ 快照读：事务开始时获取快照，整个事务期间都使用该快照。
+ 当前读：事务执行读取操作时直接读取最新的数据



# innodb如何解决幻读

一般来说，要解决脏读、不可重复读、幻读的问题就需要上升到对应的隔离等级，但是串行化隔离等级下执行效率太低，所以InnoDB一般不会用串行化隔离等级，而是用自己实现的解决方案在可重复读的隔离等级下避免幻读和不可重复读。

要解决幻读实际上是要解决在事务进行读取的时候，不能有新的数据插入。innodb是通过MVCC和行级锁来解决这个问题的。

+ 针对普通查询（select）。使用MVCC来解决。具体做法是在事务开始前形成数据快照，具体做法和可重复读隔离登记下的MVCC实现机制一样。
+ 针对select xxx for update。使用临键锁来解决。具体做法是当事务在读取数据的时候，会使用临键锁来锁住当前记录和记录附近的间隙，防止插入新的数据。



# 临键锁是怎么加的

innodb引擎在加行级锁的时候加锁的对象是索引，加锁的基本单位是加临键锁，但是在一些特殊的情况下，即使不加临键锁也能保证不出问题，这个时候临键锁就会退化。

+ 唯一索引的情况下，如果进行等值查询，并且数据存在，就会变成record锁。如果数据不存在，就变成间隙锁。
+ 普通索引的情况下，如果进行等值查询，并且记录存在，会加临键锁，再找到下一个不满足要求的记录加间隙锁。如果记录不存在，会找到第一个不满足要求的记录，然后加间隙锁。因为是普通索引（不是唯一索引，所以要确保前后都没法插入）
+ 如果不走索引，就会变成全表扫描，这个时候会给每个数据都加临键锁，相当于锁住了整张表



# 数据库死锁是怎么导致的

主要是因为间隙锁的不互斥性导致的。临键锁可能也存在这样的问题，主要取决行锁一样不一样，如果record锁不一样就不互斥）

两个事务同时获取了间隙锁，并且这两个间隙锁存在重合的区域，



# 什么是索引？有什么优缺点？什么时候要创建索引，什么时候不创建？

+ 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。



+ 优点：提高检索性能
+ 缺点：索引数量太多的话，增删数据太频繁会增加维护索引的成本。索引会占存储空间，本质上是一种用空间换时间的方法。



+ 什么时候要创建索引：查找频繁，经常需要排序的或者范围查找的字段，有unique约束的字段
+ 什么时候不创建索引：不会作为查询条件的字段，字段值区分度不高的字段，经常需要更新的字段。



# 优化索引的规则

+ 前缀索引优化：如果字段值比较长，并且部分字段值就可以
+ 覆盖索引优化：创建索引的时候使用联合索引，避免回表查询
+ 主键索引最好是自增的：插入的时候可以直接插到末尾，减少B+树的页分裂
+ 索引项最好用not null来约束



# 索引失效的情况

+ 使用左模糊匹配
+ 没有遵循最左匹配规则
+ where子句中，如果or前是索引项，or后不是索引项
+ 对索引项进行了计算，函数，类型转换等操作。



# 为什么要默认使用innoDB作为MySQL的执行引擎

+ 事务支持
+ 行级锁
+ 外键约束
+ 崩溃恢复
+ 灵活性



# 为什么InnoDB采用B+树作为索引的数据结构

+ 二叉树：树杈比较少，深度会比较深，查找的时候需要走好多层，也就是说磁盘IO的次数便较多。而且插入数据之后调整也会比较麻烦
+ B树：每个索引节点都会存放数值，导致一页能存放的节点数变少，深度相应地就变深了。叶子节点没有存放全部数据，没有用双向链表连接起来，范围查找比较麻烦
+ 哈希表：等值匹配比较合适，范围查找不合适
+ 红黑树：
+ 跳表：跳表是Redis中使用的一种数据结构，它在链表的基础上引入了层级的指针，用于跳跃地指向后面地节点，以加快查找速度。但是它需要维护很多指针信息，浪费存储空间。而且如果涉及插入删除的操作，调整起来比较麻烦。



# 为什么不用mySQL作缓存

