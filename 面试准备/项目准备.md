# 登录、校验、退出登录

## 个人总结

登录过程相当于为用户下发凭证的过程，用户登录成功后，每次提供凭证让服务器去获取用户的相关信息。

cookie，session，令牌都是实现用户登录鉴权的有效方法。它们最主要的区别在于：cookie将信息存放在用户端，用户发起请求时携带cookie。session将信息存放在服务器端，用户提供session id。令牌将信息包含在token中。

基于cookie的方式：最重要的缺点是不安全，因为存在用户端。

基于session的方式：最重要的缺点是对分布式系统来说不友好，不利于扩展。且需要在服务器端存储session信息，浪费存储空间。

基于令牌的方式：基于JWT令牌的方式最大的缺点是一旦生成传输给客户端，服务器端就无法撤销或者废除令牌。

**为什么不用JWT:** JWT存在一个比较致命的问题，就是一旦令牌下发，在有效期内无法撤销。所以一般会把它的有效期设置得比较短，或者引入一些复杂的机制来处理这个问题。



## 可能会被问到的点

<font size=5>**JWT**</font>

对head和payload分别用base64加密，然后使用头部声明的加密算法生成signature，把三个部分拼接在一起。



**JWT组成：**

+ Header：头部。包含使用的算法和令牌类型，算法默认是HS256

+ Payload：荷载。包括到期时间，发布时间，用户id等字段，还可以自定义字段

+ Signature：签名。对Header和Payload的数据签名，确保数据不被篡改



**存在的问题**：

+ 服务器不会保存会话状态，在jwt到期时间之前无法强制下线
+ jwt是不加密的，虽然不能篡改，但是payload的内容是可以被解析的
+ 数据需要基于base64进行编码，占用的长度会变长





<font size=5>**UUID和雪花算法**</font>

+ UUID：基于时间戳和计算机MAC地址生成，有128位（32位的16进制数，8-4-4-4-12），生成的ID是**无序的**。
+ 雪花算法：（需要依赖于时间戳，如果发生时钟回拨会发生错误）
  + 符号位：1位，固定为0
  + 时间戳：41位，当前时间减去固定的起始时间戳
  + 工作机器id：10位
  + 序列号：12位，表示一毫秒之内可以生成的序列号



<font size=5>**拦截器获取到Redis中的用户信息后如何传给controller？**</font>

+ 将用户信息存储到ThreadLocal中
+ 通过setAttribute存储到request当中



<font size=5>**为什么要用ThreadLocal不用request**</font>









<font size=5>**如果不用拦截器链的话怎么进行token校验**</font>

通过AOP来实现，每次收到请求之前通过Aspect来校验。

不过基于AOP的实现方式需要写切入点，基于拦截器的方式可以在配置中写排除的接口。具体用哪种方式取决于具体业务要求。



## 业务流程

**生成短信验证码**

+ 获取用户提交的手机号
+ 校验手机号合法性
+ 生成验证码
+ 将手机号作key，校验码作为value，存入Redis。并将验证码发送给用户



**短信验证码登录与注册**

+ 获取用户提交的手机号和验证码
+ 校验手机号合法性
+ 从Redis中查询验证码和手机号是否匹配
+ 如果匹配就根据用户的手机号去数据库中查找对应的用户
  + 如果用户不存在，就创建一个用户，并且为其设置一些初始化信息，将用户保存到数据库中。
+ 基于**数据传输对象模式**隐藏用户的隐私信息，将User对象转换成UserDTO对象后再转换成HashMap类型
+ 通过**UUID算法**生成随机token作为key，userMap作为value，存储到Redis上，设置token有效期。
+ 将token返回给用户



**校验登录状态**

+ 获取请求头中的token
  + 如果为空，说明用户还没有登录，直接放行
+ 如果不为空，从Redis中获取对应的用户信息。
+ 将获取到的用户信息保存在ThreadLocal中
+ 刷新Redis中token的有效期
+ 放行

----------

+ 获取ThreadLocal中的用户信息
  + 如果用户信息为空，说明没有登录，拦截
  + 如果用户信息不为空，则放行。



**退出登录**

+ 获取请求头中的token
+ 将token从Redis中删除



# 数据缓存+解决缓存穿透

## 个人总结

需要考虑数据一致性问题；以及缓存失效后，大量请求落到数据库上之后，对数据库造成冲击的问题。

【数据不一致】缓存虽然可以提高查询速度，但是和数据库之间可能会存在数据不一致的情况。如果不给缓存设置过期时间，缓存会长时间存在，用户的请求会一直落在缓存上，就无法获取数据库中更新后的最新数据了。

为了解决这一点，可以在数据库每次进行数据修改的时候都主动删除相应的缓存，等到用户再次发起请求的时候，再写入缓存。同时为缓存中的数据设置过期时间作为兜底方案。



【缓存穿透】缓存穿透指的是用户请求的对象在缓存和数据库中都不存在的时候，请求会不停地落在数据库上，数据库承受太大压力从而崩掉。解决方法包括：接口层**增强对用户的鉴权校验**，如果用户身份不合法，直接对请求进行拦截。还可以**缓存空对象**，但是如何设置空对象的过期时间也是个问题。还可以使用**布隆过滤器**，



【缓存雪崩】大量key集中过期。给不同的key设置随机的失效时间。



【缓存击穿】也就是热点key问题，缓存中的某个热点数据突然失效，而重建的时间又很久，导致对这个热点数据的请求都落在了数据库上。可以**不设置过期时间**（针对一些可以预料到的热点key），或者在访问数据的时候对数据过期时间进行**续期**。或者**通过锁**解决，允许让一个线程重建缓存，其他线程不停重试等待，或者返回旧数据（具体怎么做还是取决于业务场景，如果对数据一致性要求高就等待，要求不高就返回旧数据）



## 可能会被问到的点

<font size=5>**布隆过滤器**</font>

用于判断一个元素是否存在于一个集合中。由一个很长的二进制向量以及一系列随机映射函数组成，可以设置黑名单或者白名单。

将存在的数据通过哈希函数映射到向量中，当有请求进来的时候，也通过哈希函数对其进行映射，如果映射到的位置存在元素，说明这个请求的对象存在

布隆过滤器存在一些问题

+ 可能误判，不同的对象有可能映射到一个位置，也就是哈希碰撞。当布隆过滤器的存储快满的时候，哈希碰撞的概率也会提高，误判率相应的也会提高。要解决哈希碰撞问题可以使用多个哈希函数，校对每次计算的结果，但是会提高拦截成本。
+ 不可删除，从数据库中删除一个对象之后不能删除它在布隆过滤器中对应的位置，因为有可能别的对象也映射到了这个位置。



## 业务流程

**基于缓存空对象解决缓存穿透：**

+ 根据店铺id，从redis中查询店铺
  + 如果店铺存在，则返回店铺信息
+ 如果店铺不存在，则从数据库中获取店铺信息。
  + 如果数据库中店铺也不存在，则创建一个空对象，写入缓存中
+ 如果数据库中店铺存在，就店铺信息返回给用户，并将店铺信息写入缓存中，设置过期时间。



**基于逻辑过期解决缓存击穿：**





# 解决超卖&一人一单

## 个人总结

超卖的本质是，多线程的情况下对共享资源进行读写，查询和修改的操作没有保证原子性。

在单体架构下要解决这个问题可以基于悲观锁或者乐观锁，**基于悲观锁的方案**确实能确保数据的正确性，但是线程只能串行地执行秒杀过程，速度比较慢，而单体架构下服务器性能又会是系统的一个瓶颈，所以不太适合用悲观锁。**基于CAS乐观锁**的方案一定程度上可以解决问题。

在分布式架构下，服务器性能不再是主要的瓶颈了，所以可以考虑基于悲观锁的解决方案，但是此时仍然不能基于同步锁实现秒杀，因为JVM的锁监视器只能锁住单个**进程**，在有多个服务节点的情况下还是会导致读写问题，所以需要用到分布式锁。

可以用redis的setnx命令创建简单的分布式锁，并且设置过期时间作为兜底方案，不过过期时间的设置又会引入新的问题。如果设置得太短，在线程执行完任务前就释放了，锁就会被其他线程获取，该线程结束任务后可能会误删锁；如果设置得太长，如果服务器突然宕机，锁就长时间不被释放。

自定义的锁虽然可以在一定程度上实现分布式锁的效果，但是还存在一些问题。首先是不可重入。线程A获取了锁之后，即使在线程A内部，如果再次尝试获取相同的锁，也会被阻塞，直到锁被释放。然后是不可重试。线程A获取锁之后，线程B发现获取锁失败，会直接返回false，没有尝试重新获取锁。然后是超时释放。虽然上面的方案不会导致锁被误删，但是超时释放的问题仍然存在。最后是主从一致性。如果Redis实现了分布式集群，主从节点之间存在数据延迟，如果线程获取到锁后，主节点在数据同步完成前宕机，会出现锁丢失的问题



## 可能会被问到的点

<font size=5>**悲观锁**</font>

**存在的问题：**

+ 会阻塞其他线程，影响用户体验
+ 需要考虑加锁的时机和锁的粒度等问题，增加了调试和维护的难度



<font size=5>**乐观锁**</font>

**存在的问题：**

+ ABA问题：CAS只检查值是否相等，如果一个值是A，被修改为B后又被修改为了A，CAS是检查不出来的。当然我们的秒杀功能不考虑这个问题
+ 单体架构高并发的情况下会出现不断重试



<font size=5>**Redisson**</font>

实现可重入：

+ 获取锁时判断当前锁是否为自己持有，并且要判断自己是本线程中第几个获得锁的
+ 释放锁时要判断当前锁是否为自己持有，并且要判断可重入次数是否为0



实现可重试：【总的来说就是第一次获取失败后，就会在持有锁的线程释放后再进行重试，而不是持续重试】

+ 当线程获取锁失败后，会使用最大等待时间减去获取锁所消耗的时间，判断剩余时间是否大于零。如果剩余时间小于零，就直接返回错误信息
+ 如果剩余时间大于0，说明还有剩余时间，就通过subscribe订阅获取锁的线程释放的通知
+ 如果在等待期间最大等待时间的剩余时间耗尽了，就会调用unsubscribe方法取消订阅，并且返回获取锁失败的结果
+ 如果在剩余时间之内等到了通知，就更新剩余时间。如果剩余时间小于等于零，返回获取失败的信息
+ 如果剩余时间大于零，重新尝试获取锁



解决超时释放：【总的来说就是通过设置定时任务不断刷新有效期】

+ 默认锁的超时释放时间leaseTime为30秒，也可以根据自己的需要进行设置

+ 当线程获取锁之后，Redisson会启动一个Timeout定时任务来监控锁的有效期
+ 任务设置的delay时间是internalLockleaseTime/3（如果没有手动设置，那就是看门狗时间/3，也就是10秒），delay时间到时调用更新有效期的方法
+ 更新完有效期后再次调用定时任务，以此来重置锁的有效期
+ 在锁释放的时候取消定时任务



解决主从一致性：【使用Redis集群或者哨兵模式，而不是Redis主从结构】

+ Redis集群中有多个主节点，要求每次获取锁的时候，只有从每个结点都获取锁成功了才视为获取结点成功



## 业务流程

+ 根据用户id创建RLock锁对象
+ 尝试获取锁
  + 获取失败，直接返回错误结果
+ 获取成功则根据用户id查询兑换订单id
  + 如果发现了用户id对应的订单，则返回错误信息
+ 如果没有发现订单，则基于乐观锁扣减库存
+ 扣减失败则返回错误信息
+ 扣减成功则创建订单
+ 在finally中释放锁



# 静态数据存取

## 个人总结

静态数据可以选择存储到本地磁盘中或者云OSS（Object Storage Service）中，但是存储在本地磁盘的时候存在容量限制，文件数量过多的时候容易导致存储空间不足。除此之外，如果磁盘出现故障，就容易导致数据的丢失和泄漏（单点故障）。如果采用分布式的存储结构，就需要考虑自己维护分布式存储系统中的数据一致性问题。

云存储服务提供了高度的可扩展的存储空间，存取比较灵活，安全性也有保障，对于静态数据来说是一个存储的优秀解决方案。



## 可能会被问到的点

<font size=5>**使用云服务要考虑哪些问题**</font>

+ 安全性：在使用网络传输数据过程中是否会发生内容泄漏或者篡改
+ 高可用：能不能满足业务的并发要求，有没有流量限制



<font size=5>**文件名怎么设置**</font>

![image-20240422191816885](image/image-20240422191816885.jpg)



1. 获取原始文件后缀
2. 随机生成UUID作为文件名
3. 获取文件名的hash值进行扰动运算，获取目录名
4. 生成最终的存储目录



<font size=5>**客户端直传了解过吗**</font>

通过业务服务器传输的话，一份数据需要在互联网中传两次，会造成网络资源的浪费，也会增加服务器的资源开销，所以可以考虑客户端直传，无需经过服务器中转。

客户端直传就是客户端请求服务器获取上传所需的相关参数，服务器将参数返回给客户端后，客户端直接向OSS服务发起上传文件请求。

阿里云为客户端直传提供了三种授权模式：

+ **服务端生成STS临时访问凭证**。

  客户端被视为RAM角色，不具有确定的登录密码或访问密钥，只能获取临时的安全令牌（STS）。不过频繁的调用会引起限流，服务端可以考虑用缓存存储，然后定时刷新。

+ **服务端生成PostObject所需的签名和Post Policy**

  

+ **服务端生成PutObject所需的签名URL**



## 业务流程

**上传功能实现：**

+ 基于UUID生成文件存储路径
+ 调用工具类的方法，传入文件和新的文件名
+ 获取工具类返回的url返回给前端用于回显



**工具类实现：**

+ 根据云OSS的要求提供上传所需要的信息，一般包括域名，accessKey，secretKey，还有bucket的名字
+ 上传文件后获取返回的response
+ 从response的body中获取到存储的url